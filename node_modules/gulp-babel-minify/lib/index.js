"use strict";

var babelCore = require("babel-core");
var through2 = require("through2");
var gutil = require("gulp-util");
var applySourceMap = require("vinyl-sourcemaps-apply");
var babelPresetMinify = require("babel-preset-minify");

var PluginError = gutil.PluginError;


var NAME = "gulp-babel-minify";

module.exports = gulpBabelMinify;

function gulpBabelMinify() {
  var minifyOpts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$babel = _ref.babel,
      babel = _ref$babel === undefined ? babelCore : _ref$babel,
      _ref$minifyPreset = _ref.minifyPreset,
      minifyPreset = _ref$minifyPreset === undefined ? babelPresetMinify : _ref$minifyPreset,
      _ref$comments = _ref.comments,
      comments = _ref$comments === undefined ? /preserve|licen(s|c)e/ : _ref$comments;

  return through2.obj(function (file, enc, callback) {
    if (file.isNull()) {
      return callback(null, file);
    }

    if (file.isStream()) {
      return callback(new PluginError(NAME, "Streaming not supported"));
    }

    var inputSourceMap = void 0;
    if (file.sourceMap && file.sourceMap.mappings) {
      inputSourceMap = file.sourceMap;
    }

    var babelOpts = {
      minified: true,
      babelrc: false,
      ast: false,

      /* preset */
      presets: [[minifyPreset, minifyOpts]],

      /* sourcemaps */
      sourceMaps: !!file.sourceMap,
      inputSourceMap,

      shouldPrintComment(contents) {
        return shouldPrintComment(contents, comments);
      },

      /* file */
      filename: file.path,
      filenameRelative: file.relative
    };

    var _transform = transform({
      babel,
      input: file.contents.toString(),
      babelOpts
    }),
        result = _transform.result,
        success = _transform.success,
        error = _transform.error;

    if (success) {
      file.contents = new Buffer(result.code);
      if (file.sourceMap) {
        applySourceMap(file, result.map);
      }
      return callback(null, file);
    }

    callback(error);
  });
}

function transform(_ref2) {
  var babel = _ref2.babel,
      input = _ref2.input,
      babelOpts = _ref2.babelOpts;

  try {
    return {
      success: true,
      result: babel.transform(input, babelOpts)
    };
  } catch (e) {
    return {
      success: false,
      error: e
    };
  }
}

function shouldPrintComment(contents, predicate) {
  switch (typeof predicate) {
    case "function":
      return predicate(contents);
    case "object":
      return predicate.test(contents);
    default:
      return !!predicate;
  }
}